//  This file was generated by LevelHelper
//  http://levelhelper.wordpress.com
//
//  LevelHelperLoader.mm - online version
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////

#import "LevelHelperLoader.h"
#import "CCParallaxNode.h"
/// converts degrees to radians
#define DEGREES_TO_RADIANS(__ANGLE__) ((__ANGLE__) / 180.0f * (float)M_PI)
/// converts radians to degrees
#define RADIANS_TO_DEGREES(__ANGLE__) ((__ANGLE__) / (float)M_PI * 180.0f)


#if TARGET_OS_EMBEDDED || TARGET_OS_IPHONE || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64

#define LHRectFromString(str) CGRectFromString(str)
#define LHPointFromString(str) CGPointFromString(str)
#define LHPoint CGPoint
#define LHRect  CGRect
#define LHMakePoint(x, y) CGPointMake(x, y)

CGPoint LHPointFromValue(NSValue* val)
{
    return [val CGPointValue];
}

NSValue* LHValueWithRect(CGRect rect)
{
    return [NSValue valueWithCGRect:rect];
}

NSValue* LHValueWithPoint(CGPoint pt)
{
    return [NSValue valueWithCGPoint:pt];
}

CGRect LHRectFromValue(NSValue* val)
{
    return [val CGRectValue];
}

#else

#define LHRectFromString(str) NSRectToCGRect(NSRectFromString(str))
#define LHPointFromString(str) NSPointToCGPoint(NSPointFromString(str))
#define LHPoint NSPoint
#define LHRect NSRect
#define LHMakePoint(x, y) NSMakePoint(x, y)

CGPoint LHPointFromValue(NSValue* val)
{
    NSPoint pt = [val pointValue];
    return CGPointMake(pt.x, pt.y);
}

NSValue* LHValueWithRect(CGRect rect)
{
    return [NSValue valueWithRect:NSMakeRect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)];
}

NSValue* LHValueWithPoint(NSPoint pt)
{
    return [NSValue valueWithPoint:pt];
}

CGRect LHRectFromValue(NSValue* val)
{
    return NSRectToCGRect([val rectValue]);
}

#endif


//Special thanks to Ray Wenderlich for this CCParalaxNode category
//http://www.raywenderlich.com/3611/how-to-make-a-space-shooter-iphone-game


@interface LHPointObject : NSObject
{
	CGPoint	ratio_;
	CGPoint offset_;
	CCNode *child_;	// weak ref
}
@property (readwrite) CGPoint ratio;
@property (readwrite) CGPoint offset;
@property (readwrite,assign) CCNode *child;
+(id) pointWithCGPoint:(CGPoint)point offset:(CGPoint)offset;
-(id) initWithCGPoint:(CGPoint)point offset:(CGPoint)offset;
@end
@implementation LHPointObject
@synthesize ratio = ratio_;
@synthesize offset = offset_;
@synthesize child=child_;

+(id) pointWithCGPoint:(CGPoint)ratio offset:(CGPoint)offset
{
	return [[[self alloc] initWithCGPoint:ratio offset:offset] autorelease];
}
-(id) initWithCGPoint:(CGPoint)ratio offset:(CGPoint)offset
{
	if( (self=[super init])) {
		ratio_ = ratio;
		offset_ = offset;
	}
	return self;
}
@end

@implementation CCParallaxNode(Extras)
-(void) incrementOffset:(CGPoint)offset forChild:(CCNode*)node 
{
	for( unsigned int i=0;i < parallaxArray_->num;i++) {
		LHPointObject *point = parallaxArray_->arr[i];
		if( [[point child] isEqual:node] ) {
			[point setOffset:ccpAdd([point offset], offset)];
			break;
		}
	}
}

@end

enum LH_ACTIONS_TAGS
{
    LH_PATH_ACTION_TAG,
    LH_ANIM_ACTION_TAG
};
enum LH_JOINT_TYPE
{
	LH_DISTANCE_JOINT = 0,
	LH_REVOLUTE_JOINT,
	LH_PRISMATIC_JOINT,
	LH_PULLEY_JOINT,
	LH_GEAR_JOINT,
	LH_LINE_JOINT,
	LH_WELD_JOINT
};

bool useRetinaOnIpad = true;
////////////////////////////////////////////////////////////////////////////////
@interface LevelHelperLoader (Private)

-(void) initObjects;

-(void) addBatchNodesToLayer:(CCLayer*)cocosLayer;

-(void) setFixtureDefPropertiesFromDictionary:(NSDictionary*)spritePhysic 
									  fixture:(b2FixtureDef*)shapeDef;

-(b2Body*) b2BodyFromDictionary:(NSDictionary*)spritePhysic
			   spriteProperties:(NSDictionary*)spriteProp
						   data:(CCSprite*)ccsprite 
						  world:(b2World*)world;

-(b2Joint*) b2JointFromDictionary:(NSDictionary*)dictionary 
								world:(b2World*)world;

-(void)loadLevelHelperSceneFile:(NSString*)levelFile 
					inDirectory:(NSString*)subfolder
				   imgSubfolder:(NSString*)imgFolder;

-(void)loadLevelHelperSceneFileFromWebAddress:(NSString*)webaddress;

-(void)processLevelFileFromDictionary:(NSDictionary*)dictionary;

-(b2Body*) b2BezierBodyFromDictionary:(NSDictionary*)bezierDict world:(b2World*)world;

-(CCParallaxNode*) parallaxNodeFromDictionary:(NSDictionary*)parallaxDict 
                                        layer:(CCLayer*)layer
                                     saveDict:(NSMutableDictionary*)saveInfo;

-(void) createPathOnSprite:(CCSprite*)ccsprite withProperties:(NSDictionary*)spriteProp;

-(void) createAnimOnSprite:(CCSprite*)ccsprite withProperties:(NSDictionary*)spriteProp;

-(void) createBezierPath:(NSDictionary*)bezierDict;

-(void)saveCCFramesRectForAnimation:(NSString*)uniqueName;

@end

@implementation LevelHelperLoader

+(void) useRetinaOnIpad:(bool)value
{
    useRetinaOnIpad = value;
}
-(bool)isIpad
{
    if(!useRetinaOnIpad)
    {
        return false;
    }
    
    UIDevice* thisDevice = [UIDevice currentDevice];
    if(thisDevice.userInterfaceIdiom == UIUserInterfaceIdiomPad)
    {
        return true;
    }    
    
    return false;
}

-(NSString*)imageFile:(NSString*)file
{
    if([self isIpad])
    {   
        NSRange lastPt = [file rangeOfString:@"." options:NSBackwardsSearch];
        if(lastPt.location != NSNotFound)
        {
            NSString *newstring = [file stringByReplacingCharactersInRange:lastPt
                                                                withString:@"-hd."];
            return newstring;
            
        }
        
        return file;
    }
    
    return file;
}

////////////////////////////////////////////////////////////////////////////////
-(void) initObjects
{
    
    NSLog(@"LevelHelper WARNING: Code is still in testing. If you find any bugs please report it so I could fix it. I will remove this warning when the code has been fully tested. Thank you!");
    
	batchNodes = [[NSMutableDictionary alloc] init];	
	ccSpritesInScene = [[NSMutableDictionary alloc] init];
	noPhysicSprites = [[NSMutableDictionary alloc] init];
	ccJointsInScene = [[NSMutableDictionary alloc] init];
    ccParallaxInScene = [[NSMutableDictionary alloc] init];
    ccBeziersBodyInScene = [[NSMutableDictionary alloc] init];
    ccBezierPathsInScene = [[NSMutableDictionary alloc] init];
    ccFramesForAnimation = [[NSMutableDictionary alloc] init];
    
	addSpritesToLayerWasUsed = false;
	addObjectsToWordWasUsed = false;
    convertLevel = true;
    
    notifOnLoopForeverAnim = false;
	
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithContentOfFile:(NSString*)levelFile
{
	NSAssert(nil!=levelFile, @"Invalid file given to LevelHelperLoader");
	
	if(!(self = [super init]))
	{
		NSLog(@"LevelHelperLoader ****ERROR**** : [super init] failer ***");
		return self;
	}
	
	[self initObjects];
	[self loadLevelHelperSceneFile:levelFile inDirectory:@"" imgSubfolder:@""];
	
	
	return self;
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithContentOfFileFromInternet:(NSString*)webAddress
{
	NSAssert(nil!=webAddress, @"Invalid file given to LevelHelperLoader");
	
	if(!(self = [super init]))
	{
		NSLog(@"LevelHelperLoader ****ERROR**** : [super init] failer ***");
		return self;
	}
	
	[self initObjects];
	[self loadLevelHelperSceneFileFromWebAddress:webAddress];
	
	return self;
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithContentOfFile:(NSString*)levelFile 
			 levelSubfolder:(NSString*)levelFolder;
{
	NSAssert(nil!=levelFile, @"Invalid file given to LevelHelperLoader");
	
	if(!(self = [super init]))
	{
		NSLog(@"LevelHelperLoader ****ERROR**** : [super init] failer ***");
		return self;
	}
	
	[self initObjects];
	
	[self loadLevelHelperSceneFile:levelFile inDirectory:levelFolder imgSubfolder:@""];
	
	return self;
	
}
////////////////////////////////////////////////////////////////////////////////
-(void) convertLevel:(bool)value
{
    convertLevel = value;
}
////////////////////////////////////////////////////////////////////////////////
-(CCSpriteBatchNode*) batchNodeForFile:(NSString*) imageName
{
    NSDictionary* batchInfo = [batchNodes objectForKey:imageName];
    if(batchInfo != nil)
    {
        return [batchInfo objectForKey:@"CCBatchNode"];
    }
    return nil;
}
////////////////////////////////////////////////////////////////////////////////
-(NSArray*) batchNodesInLevel
{
    NSArray* keys = [batchNodes allKeys];
    
    NSMutableArray* batches = [[[NSMutableArray alloc] init] autorelease];
    for(NSString* img in keys)
    {
        NSDictionary* batchInfo = [batchNodes objectForKey:img];
        
        if(batchInfo != nil)
        {
            [batches addObject:[batchInfo objectForKey:@"CCBatchNode"]];
        }
    }
    
    return batches;
}
////////////////////////////////////////////////////////////////////////////////
+(int) tagForBody:(b2Body*)body
{
    return [(CCSprite*)body->GetUserData() tag];
}
////////////////////////////////////////////////////////////////////////////////
+(CCSprite*) spriteForBody:(b2Body*)body
{    
    return (CCSprite*)body->GetUserData();
}
////////////////////////////////////////////////////////////////////////////////
+(int) tagForJoint:(b2Joint*)joint
{
    LHJoint* data = (LHJoint*)joint->GetUserData();
    
    if(nil != data)
    {
        return data->tag;
    }
    return -1;
}
////////////////////////////////////////////////////////////////////////////////
-(void) addSpritesToLayer:(CCLayer*)_cocosLayer
{	
	NSAssert(addObjectsToWordWasUsed!=true, @"You can't use method addSpritesToLayer because you already used addObjectToWorld. Only one of the two can be used."); 
	NSAssert(addSpritesToLayerWasUsed!=true, @"You can't use method addSpritesToLayer again. You can only use it once. Create a new LevelHelperLoader object if you want to load the level again."); 
	
	addSpritesToLayerWasUsed = true;
	
	cocosLayer = _cocosLayer;
	
	[self addBatchNodesToLayer:cocosLayer];
	
    
    
    //we need to first create the path so we can assign the path to sprite on creation
    for(NSDictionary* bezierDict in lhBeziers)
    {
        //NSString* uniqueName = [bezierDict objectForKey:@"UniqueName"];
        if([[bezierDict objectForKey:@"IsPath"] boolValue])
        {
            [self createBezierPath:bezierDict];
        }
    }
    
    
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		//find the coresponding batch node for this sprite
		NSDictionary* batchInfo = [batchNodes objectForKey:[spriteProp objectForKey:@"Image"]];
		CCSpriteBatchNode *batch = [batchInfo objectForKey:@"CCBatchNode"];
		
		if(nil != batch)
		{
			CCSprite* ccsprite = [self spriteWithBatchFromDictionary:spriteProp batchNode:batch];
			if(nil != ccsprite)
			{
				[batch addChild:ccsprite];
				[ccSpritesInScene setObject:ccsprite forKey:[spriteProp objectForKey:@"UniqueName"]];
                
                [self setCustomAttributesForNonPhysics:spriteProp
                                                sprite:ccsprite];
			}
            
            if(![[spriteProp objectForKey:@"PathName"] isEqualToString:@"None"])
            {
                //we have a path we need to follow
                [self createPathOnSprite:ccsprite withProperties:spriteProp];
            }
            
            NSString* animName = [spriteProp objectForKey:@"AnimName"];
            if(![animName isEqualToString:@""])
            {
                //we have an animation we need to add to this sprite
                bool atStart = [[spriteProp objectForKey:@"AnimAtStart"] boolValue];
                if(atStart)
                {
                    [self createAnimOnSprite:ccsprite withProperties:spriteProp];
                }
                else
                {
                    [self saveCCFramesRectForAnimation:animName];
                }
            }
		}
	}
    
    for(NSDictionary* parallaxDict in lhParallax)
    {
        NSMutableDictionary* nodeInfo = [[[NSMutableDictionary alloc] init] autorelease];
        CCParallaxNode* node = [self parallaxNodeFromDictionary:parallaxDict layer:cocosLayer saveDict:nodeInfo];
        
        if(nil != node)
        {
            //[nodeInfo setObject:[parallaxDict objectForKey:@"ScrollSpeed"] forKey:@"ScrollSpeed"];
            [nodeInfo setObject:[parallaxDict objectForKey:@"ContinuousScrolling"] forKey:@"ContinuousScrolling"];
            [nodeInfo setObject:[parallaxDict objectForKey:@"Speed"] forKey:@"Speed"];
            [nodeInfo setObject:[parallaxDict objectForKey:@"Direction"] forKey:@"Direction"];
            [nodeInfo setObject:node forKey:@"Node"];
            [ccParallaxInScene setObject:nodeInfo forKey:[parallaxDict objectForKey:@"UniqueName"]];
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
-(void) addObjectsToWorld:(b2World*)world 
			 cocos2dLayer:(CCLayer*)_cocosLayer
{
	
	NSAssert(addSpritesToLayerWasUsed!=true, @"You can't use method addObjectsToWorld because you already used addSpritesToLayer. Only one of the two can be used."); 
	NSAssert(addObjectsToWordWasUsed!=true, @"You can't use method addObjectsToWorld again. You can only use it once. Create a new LevelHelperLoader object if you want to load the level again."); 
	
	addObjectsToWordWasUsed = true;
	
	cocosLayer = _cocosLayer;
	
	[self addBatchNodesToLayer:cocosLayer];
	
    
    //we need to first create the path so we can assign the path to sprite on creation
    for(NSDictionary* bezierDict in lhBeziers)
    {
        NSString* uniqueName = [bezierDict objectForKey:@"UniqueName"];
        if(![[bezierDict objectForKey:@"IsPath"] boolValue])
        {
            b2Body* body = [self b2BezierBodyFromDictionary:bezierDict
                                                      world:world];
            NSValue *value = [NSValue valueWithPointer:body];
            [ccBeziersBodyInScene setObject:value forKey:uniqueName];			
        }
        else
        {
            [self createBezierPath:bezierDict];
        }
    }
    
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		NSDictionary* physicProp = [dictionary objectForKey:@"PhysicProperties"];
		
		//find the coresponding batch node for this sprite
		NSDictionary* batchInfo = [batchNodes objectForKey:[spriteProp objectForKey:@"Image"]];
		CCSpriteBatchNode *batch = [batchInfo objectForKey:@"CCBatchNode"];
		
		if(nil != batch)
		{
            if(![[spriteProp objectForKey:@"IsInParallax"] boolValue])
            {
                CCSprite* ccsprite = [self spriteWithBatchFromDictionary:spriteProp batchNode:batch];
                [batch addChild:ccsprite z:[[spriteProp objectForKey:@"ZOrder"] intValue]];
			
                NSString* uniqueName = [spriteProp objectForKey:@"UniqueName"];
                if([[physicProp objectForKey:@"Type"] intValue] != 3) //3 means no physic
                {
                    b2Body* body = [self b2BodyFromDictionary:physicProp
                                             spriteProperties:spriteProp
                                                         data:ccsprite 
                                                        world:world];
                    
                    NSValue *value = [NSValue valueWithPointer:body];
                    [ccSpritesInScene setObject:value forKey:uniqueName];			
                }
                else {
                    [noPhysicSprites setObject:ccsprite forKey:uniqueName];
                    [self setCustomAttributesForNonPhysics:spriteProp
                                                    sprite:ccsprite];
                }
                
                
                if(![[spriteProp objectForKey:@"PathName"] isEqualToString:@"None"])
                {
                    //we have a path we need to follow
                    [self createPathOnSprite:ccsprite withProperties:spriteProp];
                }
                
                NSString* animName = [spriteProp objectForKey:@"AnimName"];
                if(![animName isEqualToString:@""])
                {
                    //we have an animation we need to add to this sprite
                    bool atStart = [[spriteProp objectForKey:@"AnimAtStart"] boolValue];
                    if(atStart)
                    {
                        [self createAnimOnSprite:ccsprite withProperties:spriteProp];
                    }
                    else
                    {
                        [self saveCCFramesRectForAnimation:animName];
                    }
                }
            }
		}
	}
	
	for(NSDictionary* jointDict in lhJoints)
	{
		b2Joint* boxJoint = [self b2JointFromDictionary:jointDict world:world];
		
		if(nil != boxJoint){
			[ccJointsInScene setObject:[NSValue valueWithPointer:boxJoint] 
								forKey:[jointDict objectForKey:@"UniqueName"]];	
		}
	}	
    
    for(NSDictionary* parallaxDict in lhParallax)
    {
        NSMutableDictionary* nodeInfo = [[[NSMutableDictionary alloc] init] autorelease];
        CCParallaxNode* node = [self parallaxNodeFromDictionary:parallaxDict layer:cocosLayer saveDict:nodeInfo];
        
        if(nil != node)
        {
            //[nodeInfo setObject:[parallaxDict objectForKey:@"ScrollSpeed"] forKey:@"ScrollSpeed"];
            [nodeInfo setObject:[parallaxDict objectForKey:@"ContinuousScrolling"] forKey:@"ContinuousScrolling"];
            [nodeInfo setObject:[parallaxDict objectForKey:@"Speed"] forKey:@"Speed"];
            [nodeInfo setObject:[parallaxDict objectForKey:@"Direction"] forKey:@"Direction"];
            [nodeInfo setObject:node forKey:@"Node"];
            [ccParallaxInScene setObject:nodeInfo forKey:[parallaxDict objectForKey:@"UniqueName"]];
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
-(CGPoint) pointOnCurve:(CGPoint) p1 p2:(CGPoint)p2 p3:(CGPoint)p3 p4:(CGPoint)p4 t:(float)t
{
	float var1, var2, var3;
    CGPoint vPoint = {0.0f, 0.0f};
    
    var1 = 1 - t;
    var2 = var1 * var1 * var1;
    var3 = t * t * t;
    vPoint.x = var2*p1.x + 3*t*var1*var1*p2.x + 3*t*t*var1*p3.x + var3*p4.x;
    vPoint.y = var2*p1.y + 3*t*var1*var1*p2.y + 3*t*t*var1*p3.y + var3*p4.y;
    return(vPoint);				
}
////////////////////////////////////////////////////////////////////////////////
-(CCFiniteTimeAction *) getActionSequence: (NSArray *) actions
{
    CCFiniteTimeAction *seq = nil;
    for (CCFiniteTimeAction *anAction in actions)
    {
        if (!seq){
            seq = anAction;
        }else{
            seq = [CCSequence actionOne:seq two:anAction];
        }
    }
    return seq;
}
////////////////////////////////////////////////////////////////////////////////
-(void) createBezierPath:(NSDictionary*)bezierDict
{
    int MAX_STEPS = 25;
    CGSize winSize = [[CCDirector sharedDirector] winSize];
    
    CGPoint conv = {1.0f, 1.0f};
    if(convertLevel)
        conv = convertRatio;


    
    NSMutableArray* pointsInPath = [[NSMutableArray alloc] init];
    NSString* uniqueName = [bezierDict objectForKey:@"UniqueName"];
    NSArray* curvesInShape = [bezierDict objectForKey:@"Curves"];
    bool isSimpleLine = [[bezierDict objectForKey:@"IsSimpleLine"] boolValue];
    
    bool first = true;
    for(NSDictionary* curvDict in curvesInShape)
    {
        CGPoint endCtrlPt   = LHPointFromString([curvDict objectForKey:@"EndControlPoint"]);
        CGPoint startCtrlPt = LHPointFromString([curvDict objectForKey:@"StartControlPoint"]);
        CGPoint endPt       = LHPointFromString([curvDict objectForKey:@"EndPoint"]);
        CGPoint startPt     = LHPointFromString([curvDict objectForKey:@"StartPoint"]);
        
        if(!isSimpleLine)
        {
            for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
            {
                CGPoint vPoint = [self pointOnCurve:startPt
                                                 p2:startCtrlPt
                                                 p3:endCtrlPt
                                                 p4:endPt
                                                  t:t];
    
                [pointsInPath addObject:LHValueWithPoint(LHMakePoint(vPoint.x*conv.x, winSize.height - vPoint.y*conv.y))];
            }
        }
        else
        {
            if(first)
            {
                [pointsInPath addObject:LHValueWithPoint(LHMakePoint(startPt.x*conv.x, winSize.height - startPt.y*conv.y))];            
                
                first = false;
            }
            [pointsInPath addObject:LHValueWithPoint(LHMakePoint(endPt.x*conv.x, winSize.height - endPt.y*conv.y))];            
        }
    }

    [ccBezierPathsInScene setObject:pointsInPath forKey:uniqueName];
    
}
////////////////////////////////////////////////////////////////////////////////
-(void) update:(ccTime) dt
{
    CGPoint conv = {1.0f, 1.0f};
    
    if(convertLevel)
        conv = convertRatio;

    
    NSArray* parallaxKeys = [ccParallaxInScene allKeys];
    
    for(NSString* key in parallaxKeys)
    {
        NSMutableDictionary* dic =  [ccParallaxInScene objectForKey:key];
        if(dic != nil)
        {
            if([[dic objectForKey:@"ContinuousScrolling"] boolValue])
            {
                int direction = [[dic objectForKey:@"Direction"] intValue]; //0 --> 1 ---> 2 down 3 up
                float speed = [[dic objectForKey:@"Speed"] floatValue];
                
                  
                switch (direction)
                {
                    case 1: //right to left
                    {
                        CGPoint nodeScrollDirection = ccp(-speed, 0);
                        
                        CCParallaxNode* node =  [dic objectForKey:@"Node"];
                        NSArray* spritesInNode = [dic objectForKey:@"SpritesInNode"];
                        
                        node.position = ccpAdd(node.position, ccpMult(nodeScrollDirection, dt));
                        
                        for (CCSprite *spr in spritesInNode) 
                        {
                            if ([node convertToWorldSpace:spr.position].x < -(spr.contentSize.width/2.0f)*conv.x) {
                                [node incrementOffset:ccp(2.0f*spr.contentSize.width*conv.x,0) forChild:spr];
                            }
                        }
                    }   
                    break;
                
                    case 0: //left to right
                    {
                        CGPoint nodeScrollDirection = ccp(speed, 0);
                        
                        CCParallaxNode* node =  [dic objectForKey:@"Node"];
                        NSArray* spritesInNode = [dic objectForKey:@"SpritesInNode"];
                        
                        node.position = ccpAdd(node.position, ccpMult(nodeScrollDirection, dt));
                        
                        for (CCSprite *spr in spritesInNode) 
                        {
                            if ([node convertToWorldSpace:spr.position].x > (spr.contentSize.width+ spr.contentSize.width/2.0f)*conv.x) {
                                [node incrementOffset:ccp(-2.0f*spr.contentSize.width*conv.x,0) forChild:spr];
                            }
                        }
                    }
                    break;
                        
                    case 2:
                    {
                        CGPoint nodeScrollDirection = ccp(0, -speed);
                        
                        CCParallaxNode* node =  [dic objectForKey:@"Node"];
                        NSArray* spritesInNode = [dic objectForKey:@"SpritesInNode"];
                        
                        node.position = ccpAdd(node.position, ccpMult(nodeScrollDirection, dt));
                        
                        for (CCSprite *spr in spritesInNode) 
                        {
                            if ([node convertToWorldSpace:spr.position].y < -spr.contentSize.height/2.0f*conv.y) {
                                [node incrementOffset:ccp(0, 2.0f*spr.contentSize.height*conv.y) forChild:spr];
                            }
                        }                

                    }
                    break;
                        
                    case 3:
                    {
                        CGPoint nodeScrollDirection = ccp(0, speed);
                        
                        CCParallaxNode* node =  [dic objectForKey:@"Node"];
                        NSArray* spritesInNode = [dic objectForKey:@"SpritesInNode"];
                        
                        node.position = ccpAdd(node.position, ccpMult(nodeScrollDirection, dt));
                        
                        for (CCSprite *spr in spritesInNode) 
                        {
                            if ([node convertToWorldSpace:spr.position].y > spr.contentSize.height*conv.y) {
                                [node incrementOffset:ccp(0, -2.0f*spr.contentSize.height*conv.y) forChild:spr];
                            }
                        }
                    }
                    break;
                        
                    default:
                        break;
                }                
            }  
        }
    }
    
    
    if(addSpritesToLayerWasUsed)
        return; //we dont need to update if physic is not used
    
    NSArray* keys = [ccSpritesInScene allKeys];
    
    for(NSString* name in keys)
    {
        b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:name] pointerValue];
		
        if(nil != body)
        {
            CCSprite* curSpr = [LevelHelperLoader spriteForBody:body];
            
            if(b2_dynamicBody != body->GetType()) //we dont update dynamic bodies
            {
                float angle = [curSpr rotation];
                CGPoint pos = [curSpr position];
                body->SetTransform(b2Vec2(pos.x/PTM_RATIO, pos.y/PTM_RATIO), DEGREES_TO_RADIANS(-angle));
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
-(void)restartCyclicSprite:(id)sprite data:(void*)data
{
    CCSprite *spr = (CCSprite *)sprite;
    
    
    NSDictionary* spriteProp = (NSDictionary*)data;
    NSString* uniqueName = [spriteProp objectForKey:@"PathName"];
    
    NSArray* points = [ccBezierPathsInScene objectForKey:uniqueName];
    bool pathOtherEnd = [[spriteProp objectForKey:@"PathOtherEnd"] boolValue]; //true means will restart at other end
    
    if(!pathOtherEnd)
    {
        NSArray* reversedArray = [[points reverseObjectEnumerator] allObjects];
        [ccBezierPathsInScene setObject:reversedArray forKey:uniqueName];
    }
        
    [self createPathOnSprite:spr withProperties:spriteProp];
}
////////////////////////////////////////////////////////////////////////////////
-(void) createPathOnSprite:(CCSprite*)ccsprite withProperties:(NSDictionary*)spriteProp
{
    if(nil == ccsprite || nil == spriteProp)
        return;
    
    NSString* uniqueName = [spriteProp objectForKey:@"PathName"];
    bool isCyclic = [[spriteProp objectForKey:@"PathIsCyclic"] boolValue];
    float pathSpeed = [[spriteProp objectForKey:@"PathSpeed"] floatValue];
    int startPoint = [[spriteProp objectForKey:@"PathStartPoint"] intValue]; //0 is first 1 is end
//    bool pathOtherEnd = [[spriteProp objectForKey:@"PathOtherEnd"] boolValue]; //false means will restart where it finishes
    
    NSArray* points = [ccBezierPathsInScene objectForKey:uniqueName];
    
    if(nil == points)
        return;
    
    //lets see the time interval between points 
    float interval = pathSpeed/([points count]-2);
    
    NSMutableArray* actions = [[NSMutableArray alloc] init];
    
    if(startPoint == 0)
    {
        for(size_t i = 0; i < [points count]; ++i)
        {
            NSValue* ptVal = [points objectAtIndex:i];
        
            CGPoint vPoint = LHPointFromValue(ptVal);//[ptVal CGPointValue];
            id moveToPt = [CCMoveTo actionWithDuration:interval position:CGPointMake(vPoint.x, vPoint.y)];
            [moveToPt setTag:LH_PATH_ACTION_TAG];
            [actions addObject:moveToPt]; 
        }
    }
    else
    {
        for(int i = [points count]-1; i >= 0 ; --i)
        {
            NSValue* ptVal = [points objectAtIndex:i];
            
            CGPoint vPoint = LHPointFromValue(ptVal);//[ptVal CGPointValue];
            id moveToPt = [CCMoveTo actionWithDuration:interval position:vPoint];
            [moveToPt setTag:LH_PATH_ACTION_TAG];
            [actions addObject:moveToPt];             
        }
    }
    
    if(pathNotifierId != nil && pathNotifierSel != nil)
    {
        id actionNotif = [CCCallFuncND actionWithTarget:pathNotifierId selector:pathNotifierSel data:nil];
        [actionNotif setTag:LH_PATH_ACTION_TAG];
        [actions addObject:actionNotif];
    }
    
    if(isCyclic)
    {
        id actionRestart = [CCCallFuncND actionWithTarget:self selector:@selector(restartCyclicSprite:data:) data:spriteProp];
        [actionRestart setTag:LH_PATH_ACTION_TAG];
        [actions addObject:actionRestart];
    }
    
    [ccsprite runAction:[self getActionSequence:actions]];
}
////////////////////////////////////////////////////////////////////////////////
-(void) registerNotifierOnPathEndPoints:(id)obj selector:(SEL)sel
{
    pathNotifierId = obj;
    pathNotifierSel = sel;
}
////////////////////////////////////////////////////////////////////////////////
-(void) registerNotifierOnAnimationEnds:(id)obj selector:(SEL)sel
{
    animNotifierId = obj;
    animNotifierSel = sel;
}
////////////////////////////////////////////////////////////////////////////////
-(void) enableNotifOnLoopForeverAnimations
{
    notifOnLoopForeverAnim = true;
}
////////////////////////////////////////////////////////////////////////////////
-(void)saveCCFramesRectForAnimation:(NSString*)uniqueName
{
    if([ccFramesForAnimation objectForKey:uniqueName] != nil)
        return;
    
    for(NSDictionary* anim in lhAnims)
    {
        NSString* uniqueAnimName = [anim objectForKey:@"UniqueName"];
        
        if([uniqueAnimName isEqualToString:uniqueName])
        {
            NSArray* framesInfo = [anim objectForKey:@"Frames"];

            NSMutableArray *ccframes = [NSMutableArray array];
    
            for(NSDictionary* frm in framesInfo)
            {
                NSValue* frame = LHValueWithRect(LHRectFromString([frm objectForKey:@"FrameRect"]));
                [ccframes addObject:frame];      
            }
            
            [ccFramesForAnimation setObject:ccframes forKey:uniqueAnimName];
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
-(CCFiniteTimeAction*) createAnimOnSprite:(CCSprite*)ccsprite
                               uniqueName:(NSString*)uniqueName
                                   frames:(NSArray*)framesInfo
                                     loop:(bool)loop
                              repetitions:(int)repetitions
                                    speed:(float)animSpeed
{
    if(uniqueName == nil || framesInfo == nil || [framesInfo count] == 0)
        return nil;
    
    NSMutableArray *ccframes = [NSMutableArray array];
    
    for(NSDictionary* frm in framesInfo)
    {
        CGRect rect = LHRectFromString([frm objectForKey:@"FrameRect"]);
        
        if([self isIpad])
        {
            rect.origin.x *=2.0f;
            rect.origin.y *=2.0f;
            rect.size.width *=2.0f;
            rect.size.height *=2.0f;
        }
        
        CCSpriteFrame* frame = [CCSpriteFrame frameWithTexture:[ccsprite texture] 
                                                          rect:rect];
        [ccframes addObject:frame];      
    }
    CCAnimation *anim = [CCAnimation animationWithFrames:ccframes delay:animSpeed];
    
    CCFiniteTimeAction *seq;
    if(!loop)
    {
        id animAct = [CCRepeat actionWithAction:[CCAnimate actionWithAnimation:anim 
                                                          restoreOriginalFrame:NO] 
                                          times:repetitions];
        
        if(nil != animNotifierId && nil != animNotifierSel)
        {
            id actionRestart = [CCCallFuncND actionWithTarget:animNotifierId selector:animNotifierSel data:uniqueName];
            seq = [CCSequence actionOne:animAct two:actionRestart];
        }
        else
        {
            seq = [CCSequence actions:animAct, nil];
        }
    }
    else
    {
        if(notifOnLoopForeverAnim && nil != animNotifierId && nil != animNotifierSel)
        {
            id actionRestart = [CCCallFuncND actionWithTarget:animNotifierId selector:animNotifierSel data:uniqueName];
            id animAct = [CCSequence actionOne:[CCAnimate actionWithAnimation:anim 
                                                         restoreOriginalFrame:NO] two:actionRestart];
            
            seq = [CCRepeatForever actionWithAction:animAct];
        }
        else
        {
            seq = [CCRepeatForever actionWithAction:[CCAnimate actionWithAnimation:anim 
                                                              restoreOriginalFrame:NO]];
        }
    }
    
    [seq setTag:LH_ANIM_ACTION_TAG];
    return seq;
}
////////////////////////////////////////////////////////////////////////////////
-(void) createAnimOnSprite:(CCSprite*)ccsprite withProperties:(NSDictionary*)spriteProp
{
    if(nil == ccsprite || nil == spriteProp)
        return;
    
    NSString* uniqueName = [spriteProp objectForKey:@"AnimName"];
    bool loop = [[spriteProp objectForKey:@"AnimLoop"] boolValue];
    float animSpeed = [[spriteProp objectForKey:@"AnimSpeed"] floatValue];
    int repetitions = [[spriteProp objectForKey:@"AnimRepetitions"] intValue];
   
    for(NSDictionary* anim in lhAnims)
    {
        NSString* uniqueAnimName = [anim objectForKey:@"UniqueName"];
        
        if([uniqueAnimName isEqualToString:uniqueName])
        {
            NSArray* framesInfo = [anim objectForKey:@"Frames"];
        
            CCFiniteTimeAction *seq = [self createAnimOnSprite:(CCSprite*)ccsprite
                                                    uniqueName:uniqueAnimName
                                                        frames:framesInfo
                                                          loop:loop
                                                   repetitions:repetitions
                                                         speed:animSpeed];
            
            if(seq != nil)
                [ccsprite runAction:seq];    
            //[ccAnimActionsInScene setObject:seq forKey:uniqueAnimName];
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
-(void) startAnimationWithUniqueName:(NSString *)animName onSprite:(CCSprite*)ccsprite
{
    for(NSDictionary* anim in lhAnims)
    {
        NSString* uniqueAnimName = [anim objectForKey:@"UniqueName"];
        if([animName isEqualToString:uniqueAnimName])
        {
            bool loop = [[anim objectForKey:@"LoopForever"] boolValue];
            float animSpeed = [[anim objectForKey:@"Speed"] floatValue];
            int repetitions = [[anim objectForKey:@"Repetitions"] intValue];
            
            NSArray* framesInfo = [anim objectForKey:@"Frames"];
            
            CCFiniteTimeAction *seq = [self createAnimOnSprite:ccsprite
                                                    uniqueName:uniqueAnimName
                                                        frames:framesInfo
                                                          loop:loop
                                                   repetitions:repetitions
                                                         speed:animSpeed];
            
            if(seq != nil)
                [ccsprite runAction:seq];    
        }
    }        
}
////////////////////////////////////////////////////////////////////////////////
-(void) startAnimationWithUniqueName:(NSString*)animName onSpriteWithUniqueName:(NSString*)sprName
{
    [self stopAnimationWithUniqueName:animName onSpriteWithUniqueName:sprName];
    
    CCSprite* ccsprite = [self spriteWithUniqueName:sprName];
    
    [self startAnimationWithUniqueName:animName onSprite:ccsprite];
}
////////////////////////////////////////////////////////////////////////////////
-(void) stopAnimationWithUniqueName:(NSString*)animName onSprite:(CCSprite*)ccsprite
{
    if(nil != ccsprite)
    {
        [ccsprite stopActionByTag:LH_ANIM_ACTION_TAG];
    }    
}
////////////////////////////////////////////////////////////////////////////////
-(void) stopAnimationWithUniqueName:(NSString*)animName onSpriteWithUniqueName:(NSString*)sprName
{
    CCSprite* ccsprite = [self spriteWithUniqueName:sprName];

    [self stopAnimationWithUniqueName:animName onSprite:ccsprite];
}
////////////////////////////////////////////////////////////////////////////////
-(void) nextFrameForSprite:(CCSprite*)ccsprite
{
    if(ccsprite == nil)
        return;
    
    NSMutableDictionary* sprInfo = (NSMutableDictionary*)[ccsprite userData];
    
    if(sprInfo == nil)
        return;
    
    NSArray* frames = [ccFramesForAnimation objectForKey:[sprInfo objectForKey:@"AnimName"]];
    
    if(frames == nil)
        return;
    
    int curFrame = [[sprInfo objectForKey:@"CurrentFrame"] intValue];
    
    curFrame +=1;
    if(curFrame >= 0 && curFrame < (int)[frames count])
    {
        [sprInfo setObject:[NSNumber numberWithInt:curFrame] forKey:@"CurrentFrame"];
        
        CGRect frmRect = LHRectFromValue([frames objectAtIndex:curFrame]);
        [ccsprite setTextureRect:frmRect];
    }

}
////////////////////////////////////////////////////////////////////////////////
-(void) nextFrameForSpriteWithUniqueName:(NSString*)sprName
{
    CCSprite* spr = [self spriteWithUniqueName:sprName];
    
    [self nextFrameForSprite:spr];
}
////////////////////////////////////////////////////////////////////////////////
-(void) prevFrameForSprite:(CCSprite*)spr
{
    if(spr == nil)
        return;
    
    NSMutableDictionary* sprInfo = (NSMutableDictionary*)[spr userData];
    
    if(sprInfo == nil)
        return;
    
    NSArray* frames = [ccFramesForAnimation objectForKey:[sprInfo objectForKey:@"AnimName"]];
    
    if(frames == nil)
        return;
    
    int curFrame = [[sprInfo objectForKey:@"CurrentFrame"] intValue];
    
    curFrame -=1;
    if(curFrame >= 0 && curFrame < (int)[frames count])
    {
        [sprInfo setObject:[NSNumber numberWithInt:curFrame] forKey:@"CurrentFrame"];
        
        CGRect frmRect = LHRectFromValue([frames objectAtIndex:curFrame]);
        [spr setTextureRect:frmRect];
    }    
}
////////////////////////////////////////////////////////////////////////////////
-(void) prevFrameForSpriteWithUniqueName:(NSString*)sprName
{
    CCSprite* spr = [self spriteWithUniqueName:sprName];
    [self prevFrameForSprite:spr];
}
////////////////////////////////////////////////////////////////////////////////
-(b2Body*) b2BezierBodyFromDictionary:(NSDictionary*)bezierDict world:(b2World*)world
{
    b2BodyDef bodyDef;	
	
	bodyDef.type = b2_staticBody;
	bodyDef.position.Set(0.0f, 0.0f);
	bodyDef.angle = DEGREES_TO_RADIANS(0.0f);
	
    //CREATE DUMMY CCSPRITE AND SETS ITS VISIBILITY FALSE
    
    CCSprite* spr = [[CCSprite alloc] init];
    [spr setTag:[[bezierDict objectForKey:@"Tag"] intValue]]; 
    [spr setVisible:false];
    bodyDef.userData = spr;
        
	b2Body* body = world->CreateBody(&bodyDef);
	
    bool isSimpleLine = [[bezierDict objectForKey:@"IsSimpleLine"] boolValue];
    
    NSArray* curvesInShape = [bezierDict objectForKey:@"Curves"];
    
    int MAX_STEPS = 25;
    
    CGPoint wbConv = {1.0f, 1.0f};
    
    if(convertLevel)
        wbConv = convertRatio;
  
    CGSize winSize = [[CCDirector sharedDirector] winSize];
	
    for(NSDictionary* curvDict in curvesInShape)
    {
        CGPoint endCtrlPt   = LHPointFromString([curvDict objectForKey:@"EndControlPoint"]);
        CGPoint startCtrlPt = LHPointFromString([curvDict objectForKey:@"StartControlPoint"]);
        CGPoint endPt       = LHPointFromString([curvDict objectForKey:@"EndPoint"]);
        CGPoint startPt     = LHPointFromString([curvDict objectForKey:@"StartPoint"]);
  
        if(!isSimpleLine)
        {
            CGPoint prevPoint;
            bool firstPt = true;
            for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
            {
                CGPoint vPoint = [self pointOnCurve:startPt
                                                 p2:startCtrlPt
                                                 p3:endCtrlPt
                                                 p4:endPt
                                                  t:t];
            
                if(!firstPt)
                {
                    b2Vec2 *verts = new b2Vec2[2];
                    b2PolygonShape shape;
                
                    verts[0] = b2Vec2(prevPoint.x*wbConv.x/PTM_RATIO, 
                                      (winSize.height - prevPoint.y*wbConv.y)/PTM_RATIO);
                    verts[1] = b2Vec2(vPoint.x*wbConv.x/PTM_RATIO, 
                                      (winSize.height - vPoint.y*wbConv.y)/PTM_RATIO);
                
                    shape.Set(verts, 2);		
                    b2FixtureDef fixture;
                    [self setFixtureDefPropertiesFromDictionary:bezierDict fixture:&fixture];
                    fixture.shape = &shape;
                    body->CreateFixture(&fixture);
                    delete verts;
                }
                
                prevPoint = vPoint;
                firstPt = false;
            
            }
        }
        else
        {
            b2Vec2 *verts = new b2Vec2[2];
            b2PolygonShape shape;

            verts[0] = b2Vec2(startPt.x*wbConv.x/PTM_RATIO, 
                              (winSize.height - startPt.y*wbConv.y)/PTM_RATIO);
            verts[1] = b2Vec2(endPt.x*wbConv.x/PTM_RATIO, 
                              (winSize.height - endPt.y*wbConv.x)/PTM_RATIO);
            
            shape.Set(verts, 2);		
            b2FixtureDef fixture;
            [self setFixtureDefPropertiesFromDictionary:bezierDict fixture:&fixture];
            fixture.shape = &shape;
            body->CreateFixture(&fixture);
            delete verts;

        }
    }
    
	return body;
}
////////////////////////////////////////////////////////////////////////////////
-(CCParallaxNode*) paralaxNodeWithUniqueName:(NSString*)uniqueName
{
    NSMutableDictionary* dic =  [ccParallaxInScene objectForKey:uniqueName];
    if(dic != nil)
        return [dic objectForKey:@"Node"];
    
    return nil;
}
////////////////////////////////////////////////////////////////////////////////
-(NSArray*) spritesInParallaxNodeWithUniqueName:(NSString*)uniqueName
{
    NSMutableDictionary* dic =  [ccParallaxInScene objectForKey:uniqueName];
    if(dic != nil)
        return [dic objectForKey:@"SpritesInNode"];
    
    return nil;    
}

-(NSDictionary*) generalPropDictionaryForSpriteWithUniqueName:(NSString*)name
{
    
    for(NSDictionary* dictionary in lhSprites)
    {
        NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
        
        if([[spriteProp objectForKey:@"UniqueName"] isEqualToString:name])
        {
            return spriteProp;
        }
    }
    return nil;
}
////////////////////////////////////////////////////////////////////////////////
-(CCParallaxNode*) parallaxNodeFromDictionary:(NSDictionary*)parallaxDict layer:(CCLayer*)layer saveDict:(NSMutableDictionary*)saveInfo
{
    CCParallaxNode * node = [CCParallaxNode node];
    if(cocosLayer != nil)
    {
        int z = [[parallaxDict objectForKey:@"ZOrder"] intValue];
        [cocosLayer addChild:node z:z];
    }
    
    NSArray* spritesInfo = [parallaxDict objectForKey:@"Sprites"];
    
    NSMutableArray* spritesInNode = [[[NSMutableArray alloc] init] autorelease];
    for(NSDictionary* sprInf in spritesInfo)
    {
        float ratioX = [[sprInf objectForKey:@"RatioX"] floatValue];
        float ratioY = [[sprInf objectForKey:@"RatioY"] floatValue];
        NSString* sprName = [sprInf objectForKey:@"SpriteName"];
        CCSprite* spr = [self newSpriteWithUniqueName:sprName cocos2dLayer:nil];
        
              
        if(spr != nil)
        {
            [spritesInNode addObject:spr];
            
            NSDictionary* prop = [self generalPropDictionaryForSpriteWithUniqueName:sprName];
            int z = [[prop objectForKey:@"ZOrder"] intValue];
            [node addChild:spr z:z parallaxRatio:ccp(ratioX, ratioY) positionOffset:[spr position]];
        }
    }

    [saveInfo setObject:spritesInNode forKey:@"SpritesInNode"];
    
    return node;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) isGravityZero
{
    if(gravity.x == 0 && gravity.y == 0)
        return true;
    
    return false;
}
-(void) createGravity:(b2World*)world
{
    world->SetGravity(b2Vec2(gravity.x, gravity.y));
}
-(bool) hasWorldBoundaries
{
	if(wb == nil)
	{
		return false;
	}
	
	return true;
}
////////////////////////////////////////////////////////////////////////////////
-(void) createWorldBoundaries:(b2World*)_world
{
    if(![self hasWorldBoundaries])
    {
        NSLog(@"LevelHelper WARNING - Please create world boundaries in LevelHelper in order to call method \"createWorldBoundaries\"");
        return;
    }	
    
    CGPoint wbConv = {1.0f, 1.0f};
    
    if(convertLevel)
        wbConv = convertRatio;
    
    
    b2BodyDef bodyDef;	
	
	bodyDef.type = b2_staticBody;
	bodyDef.position.Set(0.0f, 0.0f);
    b2Body* body = _world->CreateBody(&bodyDef);
	
    
    CGRect rect = LHRectFromString([wb objectForKey:@"WBRect"]);    
    CGSize winSize = [[CCDirector sharedDirector] winSize];
	
    {//TOP
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2(rect.origin.x/PTM_RATIO*wbConv.x,
                          (winSize.height - rect.origin.y*wbConv.y)/PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x + rect.size.width)*wbConv.x/PTM_RATIO, 
                          (winSize.height - rect.origin.y*wbConv.y)/PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        [self setFixtureDefPropertiesFromDictionary:wb fixture:&fixture];
        fixture.shape = &shape;
        fixture.isSensor = false;
        body->CreateFixture(&fixture);
        delete verts;
    }

    {//LEFT
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2(rect.origin.x*wbConv.x/PTM_RATIO,
                          (winSize.height - rect.origin.y*wbConv.y)/PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x*wbConv.x)/PTM_RATIO, 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        [self setFixtureDefPropertiesFromDictionary:wb fixture:&fixture];
        fixture.shape = &shape;
        body->CreateFixture(&fixture);
        delete verts;
    }

    {//RIGHT
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2((rect.origin.x + rect.size.width)*wbConv.x/PTM_RATIO,
                          (winSize.height - rect.origin.y*wbConv.y)/PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x+ rect.size.width)*wbConv.x/PTM_RATIO, 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        [self setFixtureDefPropertiesFromDictionary:wb fixture:&fixture];
        fixture.shape = &shape;
        body->CreateFixture(&fixture);
        delete verts;
    }

    {//BOTTOM
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2(rect.origin.x*wbConv.x/PTM_RATIO,
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x+ rect.size.width)*wbConv.x/PTM_RATIO, 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        [self setFixtureDefPropertiesFromDictionary:wb fixture:&fixture];
        fixture.shape = &shape;
        fixture.isSensor = false;
        body->CreateFixture(&fixture);
        delete verts;
    }
}
////////////////////////////////////////////////////////////////////////////////
-(unsigned int) numberOfBatchNodesUsed
{
	return (int)[batchNodes count] -1;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) isSpriteWithUniqueName:(NSString*)name atPoint:(CGPoint)point
{
    CCSprite* sprite = [self spriteWithUniqueName:name];
    
    if(nil == sprite)
        return false;
    
    CGPoint position = [sprite position];
    CGSize size = [sprite contentSize];
    
    if((point.x > position.x - size.width/2) &&
       (point.x < position.x + size.width/2) &&
       (point.y > position.y - size.height/2) &&
       (point.y < position.y + size.height/2))
        return true;
    
    return false;
}
////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) spriteWithUniqueName:(NSString*)name
{
	if(addSpritesToLayerWasUsed)
	{
		return [ccSpritesInScene objectForKey:name];	
	}
	else if(addObjectsToWordWasUsed)
	{
		b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:name] pointerValue];
		
		if(nil != body)
			return (CCSprite*)[LevelHelperLoader spriteForBody:body];//->GetUserData()
		else {
			CCSprite* sprite = (CCSprite*)[noPhysicSprites objectForKey:name];
			
			return sprite;
		}
	}
	
	return nil;
}
////////////////////////////////////////////////////////////////////////////////
-(b2Body*) bodyWithUniqueName:(NSString*)name
{
	if(addObjectsToWordWasUsed)
	{
		b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:name] pointerValue];
		
		return body;
	}
	
	return nil;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeSpriteWithUniqueName:(NSString*)name
{
	//NSAssert(addObjectsToWordWasUsed!=true, @"You cannot remove a sprite with method removeCCSpriteWithUniqueName if you used the method addObjectToWorld to load your level. Use method removeBody."); 
	
	CCSprite* ccsprite = nil;
	if(!addObjectsToWordWasUsed)
	{
		ccsprite = [ccSpritesInScene objectForKey:name];
	}
	else {
		ccsprite = [noPhysicSprites objectForKey:name];
	}
	if(nil == ccsprite)
	{
		return false;
	}
	
	if([ccsprite usesBatchNode])
	{
		CCSpriteBatchNode *batchNode = [ccsprite batchNode];
		
		[batchNode removeChild:ccsprite cleanup:YES];
	}
	else {
		NSLog(@"This CCSprite was not created using a batch node so it's your responsibility to remove it.");
		return false;
	}
	
	
	if(!addObjectsToWordWasUsed)
	{
		[ccSpritesInScene removeObjectForKey:name];
	}
	else {
		[noPhysicSprites removeObjectForKey:name];
	}
	
	
	return true;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeSprite:(CCSprite*)ccsprite
{
	if(nil == ccsprite)
		return false;
	
	if([ccsprite usesBatchNode])
	{
		NSArray * keys= nil;
		if(!addObjectsToWordWasUsed)
			keys = [ccSpritesInScene allKeysForObject:ccsprite];
		else {
			keys = [noPhysicSprites allKeysForObject:ccsprite];
		}
		
		CCSpriteBatchNode *batchNode = [ccsprite batchNode];
		
		[batchNode removeChild:ccsprite cleanup:YES];
		
		for(NSString* key in keys)
		{
			if(!addObjectsToWordWasUsed)
				[ccSpritesInScene removeObjectForKey:key];
			else {
				[noPhysicSprites removeObjectForKey:key];
			}
			
		}
	}
	else 
	{
		NSLog(@"This CCSprite was not created using a batch node so it's your responsibility to remove it.");
		return false;
	}
	
	return true;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeAllSprites
{	
	//NSAssert(addObjectsToWordWasUsed!=true, @"You cannot remove all sprites with method removeAllCCSprites if you used the method addObjectToWorld to load your level. Use method removeAllBodies."); 
	
	NSArray *keys = nil;
	if(!addObjectsToWordWasUsed)
		keys = [ccSpritesInScene allKeys];
	else {
		keys = [noPhysicSprites allKeys];
	}
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
		removedAll = removedAll == [self removeSpriteWithUniqueName:key];
	}
	
	return removedAll;	
}
-(bool) removeAllParallaxSprites
{
    NSArray* keys = [ccParallaxInScene allKeys];
    
    for(NSString* key in keys)
    {
        NSArray* sprites = [self spritesInParallaxNodeWithUniqueName:key];
        
        for(CCSprite* spr in sprites)
        {
            [cocosLayer removeChild:spr cleanup:YES];
        }
    }
    return true;
}
////////////////////////////////////////////////////////////////////////////////
-(void) removeFromBatchNode:(CCSprite*)sprite
{
	CCSpriteBatchNode *batchNode = [sprite batchNode];
	
	if(nil == batchNode)
		return;
	
	[batchNode removeChild:sprite cleanup:YES];
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeBodyWithUniqueName:(NSString*)name
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a body with method removeBodyWithUniqueName if you used the method addSpritesToLayer to load your level. Use method removeCCSprite or removeCCSpriteWithUniqueName."); 
	
	b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:name] pointerValue];
	
	if(0 != body)
	{
		return [self removeBody:body];
	}
	
	return false;
}
////////////////////////////////////////////////////////////////////////////////
//-(bool) removeBody:(b2Body*)body
//{
//	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a body with method removeBody if you used the method addSpritesToLayer to load your level. Use method removeCCSprite or removeCCSpriteWithUniqueName."); 
//	
//	if(0 == body)
//		return false;
//	
//	CCSprite *ccsprite = (CCSprite*)[LevelHelperLoader spriteForBody:body];//->GetUserData();
//	
//	if(nil == ccsprite)
//		return false;
//	
//	if([ccsprite usesBatchNode])
//	{
//		NSArray * keys = [ccSpritesInScene allKeysForObject:[NSValue valueWithPointer:body]];
//		
//		CCSpriteBatchNode *batchNode = [ccsprite batchNode];
//		
//		if(nil == batchNode)
//			return false;
//		
//		b2World* _world = body->GetWorld();
//		
//		if(0 == _world)
//			return false;
//		
//		[batchNode removeChild:ccsprite cleanup:YES];
//		
//		for(NSString* key in keys)
//		{
//			[ccSpritesInScene removeObjectForKey:key];
//		}
//		        
//		_world->DestroyBody(body);
//	}
//	else 
//	{
//		NSLog(@"This b2Body was not created using a addObjectToWorld so it's your responsibility to remove it.");
//		return false;
//	}
//	
//	return true;
//}

-(bool) removeBody:(b2Body*)body
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a body with method removeBody if you used the method addSpritesToLayer to load your level. Use method removeCCSprite or removeCCSpriteWithUniqueName."); 
	
	if(0 == body)
		return false;
	
	CCSprite *ccsprite = (CCSprite*)[LevelHelperLoader spriteForBody:body];//->GetUserData();
	
	if(nil == ccsprite)
		return false;
	
    b2World* _world = body->GetWorld();
    
	if([ccsprite usesBatchNode])
	{
		NSArray * keys = [ccSpritesInScene allKeysForObject:[NSValue valueWithPointer:body]];
		
		CCSpriteBatchNode *batchNode = [ccsprite batchNode];
		
		if(nil == batchNode)
			return false;
		
		
		
		if(0 == _world)
			return false;
		
		[batchNode removeChild:ccsprite cleanup:YES];
		
		for(NSString* key in keys)
		{
			[ccSpritesInScene removeObjectForKey:key];
		}
	}
    else
    {
        [cocosLayer removeChild:ccsprite cleanup:YES];
    }    
    
    if(0 == body)
        return false;
    
    _world->DestroyBody(body);
    
	//else 
	//{
	//	NSLog(@"This b2Body was not created using a addObjectToWorld so it's your responsibility to remove it.");
	//	return false;
	//}
	
	return true;
}

-(bool) removeBodiesWithTag:(LevelHelper_TAG)tag
{
    NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove bodies with method removeBodiesWithTag if you used the method addSpritesToLayer to load your level. Use method removeAllCCSprites."); 
	
	NSArray *keys = [ccSpritesInScene allKeys];
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
        b2Body* body = [self bodyWithUniqueName:key];
        if(tag == [LevelHelperLoader tagForBody:body])
        {
            removedAll = removedAll == [self removeBody:body];    
        }
	}
	return removedAll;		
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeAllBodies
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove all bodies with method removeAllBodies if you used the method addSpritesToLayer to load your level. Use method removeAllCCSprites."); 
	
	NSArray *keys = [ccSpritesInScene allKeys];
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
		removedAll = removedAll == [self removeBodyWithUniqueName:key];
	}
	return removedAll;		
}
////////////////////////////////////////////////////////////////////////////////
-(b2Joint*) jointWithUniqueName:(NSString*)name
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a joint with method removeJointWithUniqueName if you used the method addSpritesToLayer to load your level."); 
	
	
	b2Joint* joint = (b2Joint*)[[ccJointsInScene objectForKey:name] pointerValue];
	
	return joint;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeJointWithUniqueName:(NSString*)name
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a joint with method removeJointWithUniqueName if you used the method addSpritesToLayer to load your level."); 
	
	
	b2Joint* joint = (b2Joint*)[[ccJointsInScene objectForKey:name] pointerValue];
	
	if(0 != joint)
	{
		return [self removeJoint:joint];
	}
	
	return false;
}
////////////////////////////////////////////////////////////////////////////////
-(NSMutableArray*) jointsWithTag:(LevelHelper_TAG)tag
{
    NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot use method jointsWithTag if you used the method addSpritesToLayer to load your level."); 
    
	NSArray *keys = [ccJointsInScene allKeys];
	
    NSMutableArray* jointsWithTag = [[[NSMutableArray alloc] init] autorelease];
	for(NSString* key in keys)
	{
		b2Joint* joint = [self jointWithUniqueName:key];
        
        if([LevelHelperLoader tagForJoint:joint] == tag)
        {
            [jointsWithTag addObject:[NSValue valueWithPointer:joint]];
        }
	}
    
    return jointsWithTag;
}
////////////////////////////////////////////////////////////////////////////////
//use this method to remove multiple joints at once
-(void) removeAllJointsWithTag:(LevelHelper_TAG)tag
{
    NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove joints with method removeAllJointsWithTag if you used the method addSpritesToLayer to load your level."); 
    
	NSArray *keys = [ccJointsInScene allKeys];
	
	for(NSString* key in keys)
	{
		b2Joint* joint = [self jointWithUniqueName:key];
    
        if([LevelHelperLoader tagForJoint:joint] == tag)
        {
            [self removeJoint:joint];
        }
	}
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeAllJoints
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove joints with method removeAllJoints if you used the method addSpritesToLayer to load your level."); 

	NSArray *keys = [ccJointsInScene allKeys];
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
		removedAll = removedAll == [self removeJointWithUniqueName:key];
	}
	return removedAll;	
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(bool) removeJoint:(b2Joint*) joint
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a joint with method removeJoint if you used the method addSpritesToLayer to load your level."); 
	
	if(0 == joint)
		return false;
	
	b2Body *body = joint->GetBodyA();
	
	if(0 == body)
	{
		body = joint->GetBodyB();
		
		if(0 == body)
			return false;
	}
	
	NSArray * keys = [ccJointsInScene allKeysForObject:[NSValue valueWithPointer:joint]];
	
	b2World* _world = body->GetWorld();
	
	if(0 == _world)
		return false;
	

    LHJoint* jData = (LHJoint*)joint->GetUserData();
    delete jData;
    
	for(NSString* key in keys)
	{
		[ccJointsInScene removeObjectForKey:key];
	}
	_world->DestroyJoint(joint);
	
	
	return true;
}

-(CCSprite*) newSpriteWithUniqueName:(NSString *)uniqueName
{
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if([[spriteProp objectForKey:@"UniqueName"] isEqualToString:uniqueName])
		{
            NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
            
            //find the coresponding batch node for this sprite
            NSDictionary* batchInfo = [batchNodes objectForKey:[spriteProp objectForKey:@"Image"]];
            CCSpriteBatchNode *batch = [batchInfo objectForKey:@"CCBatchNode"];
            
            if(nil != batch)
            {
                CCSprite* ccsprite = [self spriteWithBatchFromDictionary:spriteProp batchNode:batch];
                [batch addChild:ccsprite z:[[spriteProp objectForKey:@"ZOrder"] intValue]];
                
                return ccsprite;
            }
        }
    }
    return nil;
}

////////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) newSpriteWithUniqueName:(NSString*)uniqueName 
						  cocos2dLayer:(CCLayer*)_cocosLayer
{
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if([[spriteProp objectForKey:@"UniqueName"] isEqualToString:uniqueName])
		{
            NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];
			
			if(nil != ccsprite)
				[_cocosLayer addChild:ccsprite];
			
			return ccsprite;
		}
	}
	return nil;
}
////////////////////////////////////////////////////////////////////////////////////
-(b2Body*) newBodyWithUniqueName:(NSString*)uniqueName 
						   world:(b2World*)_world
					cocos2dLayer:(CCLayer*)_cocosLayer
{
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if([[spriteProp objectForKey:@"UniqueName"] isEqualToString:uniqueName])
		{
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];	
			
			if(nil == ccsprite)
				return 0;
			
			[_cocosLayer addChild:ccsprite];
			
			NSDictionary* physicProp = [dictionary objectForKey:@"PhysicProperties"];
			
			return [self b2BodyFromDictionary:physicProp
							 spriteProperties:spriteProp
										 data:ccsprite 
										world:_world];
		}
	}
	
	return 0;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSMutableArray*)spritesWithTag:(LevelHelper_TAG)tag
{
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	NSArray *keys = [ccSpritesInScene allKeys];
	for(NSString* key in keys)
	{
		CCSprite* ccSprite = nil;
		if(addSpritesToLayerWasUsed)
		{
			ccSprite = [ccSpritesInScene objectForKey:key];
		}
		else 
		{
			b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:key] pointerValue];
			if(0 != body)
            {
				ccSprite = (CCSprite*)[LevelHelperLoader spriteForBody:body];//->GetUserData();
            }			
		}
		
		if(nil != ccSprite && [ccSprite tag] == (int)tag)
		{
			[array addObject:ccSprite];
		}
	}
    
    if(addObjectsToWordWasUsed)
    {

        NSArray *no_phys_keys = [noPhysicSprites allKeys];
        for(NSString* key in no_phys_keys)
        {
            CCSprite* ccSprite = [noPhysicSprites objectForKey:key];
		
            if(nil != ccSprite && [ccSprite tag] == (int)tag)
            {
                [array addObject:ccSprite];
            }
        }
    }
	
	return array;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSMutableArray*) bodiesWithTag:(LevelHelper_TAG)tag
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot use method BodiesWithTag if you used the method addSpritesToLayer to load your level."); 
	
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	NSArray *keys = [ccSpritesInScene allKeys];
	for(NSString* key in keys)
	{
		b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:key] pointerValue];
		CCSprite* ccSprite = (CCSprite*)[LevelHelperLoader spriteForBody:body];//->GetUserData();
		
		if(nil != ccSprite && [ccSprite tag] == (int)tag)
		{
			[array addObject:[NSValue valueWithPointer:body]];
		}
	}
	
	return array;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSMutableArray*)newSpritesWithTag:(LevelHelper_TAG)tag
						 cocos2dLayer:(CCLayer*)_cocosLayer
{
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if((LevelHelper_TAG)[[spriteProp objectForKey:@"Tag"] intValue] == tag)
		{
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];
			
			if(nil != ccsprite)
			{
				[array addObject:ccsprite];
				[_cocosLayer addChild:ccsprite];
			}
		}
	}
	
	return array;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSMutableArray*) newBodiesWithTag:(LevelHelper_TAG)tag 
							  world:(b2World*)_world
					   cocos2dLayer:(CCLayer*)_cocosLayer
{
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if((LevelHelper_TAG)[[spriteProp objectForKey:@"Tag"] intValue] == tag)
		{
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];
			
			if(nil != ccsprite)
			{
				NSDictionary* physicProp = [dictionary objectForKey:@"PhysicProperties"];
				
				NSValue* v = [NSValue valueWithPointer:[self b2BodyFromDictionary:physicProp
																 spriteProperties:spriteProp
																			 data:ccsprite 
																			world:_world]];
				
				
				
				[array addObject:v];
				
				[_cocosLayer addChild:ccsprite];
			}
		}
	}
	return array;
}
////////////////////////////////////////////////////////////////////////////////////
-(void) releaseAll
{
    NSArray *spritekeys = [ccSpritesInScene allKeys];
	for(NSString* key in spritekeys)
    {
        CCSprite* spr = [self spriteWithUniqueName:key];
        
        [spr stopAllActions];
    }
    
	[lhSprites release];
	[lhJoints release];
    [lhParallax release];
    [lhBeziers release];
	
	if(addObjectsToWordWasUsed){
		[self removeAllJoints];	
		[self removeAllBodies];
		[self removeAllSprites]; //for no physic sprites
	}
	else {
		[self removeAllSprites];
	}
	[ccSpritesInScene release];
	[ccJointsInScene release];
	[noPhysicSprites release];
    
    [self removeAllParallaxSprites];
    [ccParallaxInScene release];
    
    NSArray *bezierkeys = [ccBeziersBodyInScene allKeys];
	for(NSString* key in bezierkeys)
    {  
        NSValue *value = [ccBeziersBodyInScene objectForKey:key];
        b2Body* body = (b2Body*)[value pointerValue];
        
        CCSprite* spr = (CCSprite*)body->GetUserData();
        [spr release];
    }
    [ccBeziersBodyInScene release];
	[ccBezierPathsInScene release];
    
    [ccFramesForAnimation release];
    
	NSArray *keys = [batchNodes allKeys];
	for(NSString* key in keys)
	{
		NSDictionary* info = [batchNodes objectForKey:key];
		
		CCSpriteBatchNode *v = [info objectForKey:@"CCBatchNode"];
		[cocosLayer removeChild:v cleanup:true];
	}
	[batchNodes release];
}
////////////////////////////////////////////////////////////////////////////////////
-(void) release
{
	[self releaseAll];
}
///////////////////////////PRIVATE METHODS//////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
-(void) addBatchNodesToLayer:(CCLayer*)_cocosLayer
{
	NSArray *keys = [batchNodes allKeys];
	int tag = 0;
	for(NSString* key in keys)
	{
		NSDictionary* info = [batchNodes objectForKey:key];
		
		CCSpriteBatchNode *v = [info objectForKey:@"CCBatchNode"];
		int z = [[info objectForKey:@"OrderZ"] intValue];
		[_cocosLayer addChild:v z:z tag:tag];
		tag++;
	}
}
////////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) spriteFromDictionary:(NSDictionary*)spriteProp
{
    CGRect uv = LHRectFromString([spriteProp objectForKey:@"UV"]);
    
    if([self isIpad])
    {
        uv.origin.x *=2.0f;
        uv.origin.y *=2.0f;
        uv.size.width *=2.0f;
        uv.size.height *=2.0f;
    }
    
	CCSprite *ccsprite = [CCSprite spriteWithFile:[self imageFile:[spriteProp objectForKey:@"Image"]]
											 rect:uv];
	
	[self setSpriteProperties:ccsprite spriteProperties:spriteProp];
	
	return ccsprite;
}
////////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) spriteWithBatchFromDictionary:(NSDictionary*)spriteProp 
								   batchNode:(CCSpriteBatchNode*)batch
{
    CGRect uv = LHRectFromString([spriteProp objectForKey:@"UV"]);
        
    if([self isIpad])
    {
        uv.origin.x *=2.0f;
        uv.origin.y *=2.0f;
        uv.size.width *=2.0f;
        uv.size.height *=2.0f;
    }

    
 	CCSprite *ccsprite = [CCSprite spriteWithBatchNode:batch 
												  rect:uv];
	
	[self setSpriteProperties:ccsprite spriteProperties:spriteProp];
	
	return ccsprite;	
}
////////////////////////////////////////////////////////////////////////////////////
-(void) setSpriteProperties:(CCSprite*)ccsprite
			 spriteProperties:(NSDictionary*)spriteProp
{
	//convert position from LH to Cocos2d coordinates
	CGSize winSize = [[CCDirector sharedDirector] winSize];
	CGPoint position = LHPointFromString([spriteProp objectForKey:@"Position"]);

    if(convertLevel)
    {
        position.x *= convertRatio.x;
        position.y *= convertRatio.y;
    }
    
    position.y = winSize.height - position.y;

	[ccsprite setPosition:position];
	[ccsprite setRotation:[[spriteProp objectForKey:@"Angle"] floatValue]];
	[ccsprite setOpacity:255*[[spriteProp objectForKey:@"Opacity"] floatValue]];
	CGRect color = LHRectFromString([spriteProp objectForKey:@"Color"]);
	[ccsprite setColor:ccc3(255*color.origin.x, 255*color.origin.y, 255*color.size.width)];
	CGPoint scale = LHPointFromString([spriteProp objectForKey:@"Scale"]);
      
    if(convertLevel)
    {
        scale.x *= convertRatio.x;
        scale.y *= convertRatio.y;
    }

    if([self isIpad])
    {
        scale.x /=2;
        scale.y /=2;
    }

	[ccsprite setScaleX:scale.x];
	[ccsprite setScaleY:scale.y];
     
	[ccsprite setTag:[[spriteProp objectForKey:@"Tag"] intValue]];
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(void) setFixtureDefPropertiesFromDictionary:(NSDictionary*)spritePhysic 
									  fixture:(b2FixtureDef*)shapeDef
{
	shapeDef->density = [[spritePhysic objectForKey:@"Density"] floatValue];
	shapeDef->friction = [[spritePhysic objectForKey:@"Friction"] floatValue];
	shapeDef->restitution = [[spritePhysic objectForKey:@"Restitution"] floatValue];
	
	shapeDef->filter.categoryBits = [[spritePhysic objectForKey:@"Category"] intValue];
	shapeDef->filter.maskBits = [[spritePhysic objectForKey:@"Mask"] intValue];
	shapeDef->filter.groupIndex = [[spritePhysic objectForKey:@"Group"] intValue];
    
    shapeDef->isSensor = [[spritePhysic objectForKey:@"IsSenzor"] boolValue];
}
////////////////////////////////////////////////////////////////////////////////////
-(b2Body*) b2BodyFromDictionary:(NSDictionary*)spritePhysic
			   spriteProperties:(NSDictionary*)spriteProp
						   data:(CCSprite*)ccsprite 
						  world:(b2World*)_world
{
	b2BodyDef bodyDef;	
	
	b2Vec2 position = b2Vec2([ccsprite position].x/PTM_RATIO,[ccsprite position].y/PTM_RATIO);

	int bodyType = [[spritePhysic objectForKey:@"Type"] intValue];
	if(bodyType == 3) //in case the user wants to create a body with a sprite that has type as "NO_PHYSIC"
		bodyType = 2;
	bodyDef.type = (b2BodyType)bodyType;
	bodyDef.position.Set(position.x, position.y);//[ccsprite positionInPixels].x/PTM_RATIO,[ccsprite positionInPixels].y/PTM_RATIO);
	bodyDef.angle = DEGREES_TO_RADIANS(-1*[[spriteProp objectForKey:@"Angle"] floatValue]);
	
    bodyDef.userData = ccsprite;
    
	b2Body* body = _world->CreateBody(&bodyDef);
    
    NSMutableDictionary* spriteUserData = [[NSMutableDictionary alloc] init];
    [spriteUserData setObject:[spriteProp objectForKey:@"UniqueName"] forKey:@"UniqueName"];
    [spriteUserData setObject:[NSValue valueWithPointer:body] forKey:@"Body"];
    [spriteUserData setObject:[spriteProp objectForKey:@"AnimName"] forKey:@"AnimName"];
    [spriteUserData setObject:[NSNumber numberWithInt:0] forKey:@"CurrentFrame"];
    
    [ccsprite setUserData:spriteUserData];
	
	body->SetFixedRotation([[spritePhysic objectForKey:@"FixedRot"] boolValue]);
	
	NSArray* fixtures = [spritePhysic objectForKey:@"ShapeFixtures"];
	CGPoint scale = LHPointFromString([spriteProp objectForKey:@"Scale"]); 
    
    CGPoint size = LHPointFromString([spriteProp objectForKey:@"Size"]);
    
    CGPoint border = LHPointFromString([spritePhysic objectForKey:@"ShapeBorder"]);
    
    if(convertLevel)
    {
        scale.x *= convertRatio.x;
        scale.y *= convertRatio.y;
        
       // border.x *= convertRatio.x;
       // border.y *= convertRatio.y;
    }

	if(fixtures == nil || [fixtures count] == 0 || [[fixtures objectAtIndex:0] count] == 0)
	{
		b2PolygonShape shape;
		b2FixtureDef fixture;
		b2CircleShape circle;
		[self setFixtureDefPropertiesFromDictionary:spritePhysic fixture:&fixture];
		
		if([[spritePhysic objectForKey:@"IsCircle"] boolValue])
		{
            if(convertLevel)
            {
            //    NSLog(@"convert circle");
                //this is for the ipad scale on circle look weird if we dont do this
                float scaleSpr = [ccsprite scaleX];
                [ccsprite setScaleY:scaleSpr];
            }
            
			circle.m_radius = (size.x*scale.x/2 - border.x*scale.x)/PTM_RATIO;
			fixture.shape = &circle;
            body->CreateFixture(&fixture);
		}
		else
		{
            //THIS WAS ADDED BECAUSE I DISCOVER A BUG IN BOX2d
            //that makes linearImpulse to not work the body is in contact with
            //a box object
            int vsize = 4;
			b2Vec2 *verts = new b2Vec2[vsize];
			b2PolygonShape shape;
			
            verts[0].x = ( (-1* size.x + border.x/2.0f)*scale.x/2.0f)/PTM_RATIO;
            verts[0].y = ( (-1* size.y + border.y/2.0f)*scale.y/2.0f)/PTM_RATIO;

            verts[1].x = ( (+ size.x - border.x/2.0f)*scale.x/2.0f)/PTM_RATIO;
            verts[1].y = ( (-1* size.y + border.y/2.0f)*scale.y/2.0f)/PTM_RATIO;

            verts[2].x = ( (+ size.x - border.x/2.0f)*scale.x/2.0f)/PTM_RATIO;
            verts[2].y = ( (+ size.y - border.y/2.0f)*scale.y/2.0f)/PTM_RATIO;

            verts[3].x = ( (-1* size.x + border.x/2.0f)*scale.x/2.0f)/PTM_RATIO;
            verts[3].y = ( (+ size.y - border.y/2.0f)*scale.y/2.0f)/PTM_RATIO;
            
			shape.Set(verts, vsize);		

//            shape.SetAsBox((size.x*scale.x - border.x)/PTM_RATIO/2, 
//						   (size.y*scale.y - border.y)/PTM_RATIO/2);
            
			fixture.shape = &shape;
            body->CreateFixture(&fixture);
            delete verts;
		}
	}
	else
	{
		for(NSArray* curFixture in fixtures)
		{
			int size = (int)[curFixture count];
			b2Vec2 *verts = new b2Vec2[size];
			b2PolygonShape shape;
			int i = 0;
			for(NSString* pointStr in curFixture)
			{
				CGPoint point = LHPointFromString(pointStr);
				verts[i] = b2Vec2(point.x*(scale.x)/PTM_RATIO, 
								  point.y*(scale.y)/PTM_RATIO);
				++i;
			}
			shape.Set(verts, size);		
			b2FixtureDef fixture;
			[self setFixtureDefPropertiesFromDictionary:spritePhysic fixture:&fixture];
			fixture.shape = &shape;
			body->CreateFixture(&fixture);
			delete verts;
		}
	}

    [self setCustomAttributesForPhysics:spriteProp 
                         body:body
                       sprite:ccsprite];
	
	return body;
	
}


-(void) setCustomAttributesForPhysics:(NSDictionary*)spriteProp 
                       body:(b2Body*)body
                     sprite:(CCSprite*)sprite
{
    
}
-(void) setCustomAttributesForNonPhysics:(NSDictionary*)spriteProp 
                                  sprite:(CCSprite*)sprite
{
    
}

////////////////////////////////////////////////////////////////////////////////////
-(b2Joint*) b2JointFromDictionary:(NSDictionary*)joint world:(b2World*)world
{
	if(nil == joint)
		return 0;
	
	if(world == 0)
		return 0;
	
	b2Body* bodyA = (b2Body*)[[ccSpritesInScene objectForKey:[joint objectForKey:@"ObjectA"]] pointerValue];
	b2Body* bodyB = (b2Body*)[[ccSpritesInScene objectForKey:[joint objectForKey:@"ObjectB"]] pointerValue];
	
	CGPoint anchorA = LHPointFromString([joint objectForKey:@"AnchorA"]);
	CGPoint anchorB = LHPointFromString([joint objectForKey:@"AnchorB"]);
	bool collideConnected = [[joint objectForKey:@"CollideConnected"] boolValue];
	
    int tag = [[joint objectForKey:@"Tag"] intValue];
    
	b2Vec2 posA, posB;
	
    if(![[joint objectForKey:@"CenterOfMass"] boolValue])
    {
        posA = b2Vec2((bodyA->GetWorldCenter().x*PTM_RATIO + anchorA.x)/PTM_RATIO, 
                      (bodyA->GetWorldCenter().y*PTM_RATIO - anchorA.y)/PTM_RATIO);
        
        posB = b2Vec2((bodyB->GetWorldCenter().x*PTM_RATIO + anchorB.x)/PTM_RATIO, 
                      (bodyB->GetWorldCenter().y*PTM_RATIO - anchorB.y)/PTM_RATIO);
    }
    else {		
        posA = b2Vec2((bodyA->GetWorldCenter().x)/PTM_RATIO, 
                      (bodyA->GetWorldCenter().y)/PTM_RATIO);
        
        posB = b2Vec2((bodyB->GetWorldCenter().x)/PTM_RATIO, 
                      (bodyB->GetWorldCenter().y)/PTM_RATIO);					
    }
	
	if(0 != bodyA && 0 != bodyB)
	{
		switch ([[joint objectForKey:@"Type"] intValue])
		{
			case LH_DISTANCE_JOINT:
			{
				//LHDistanceJoint* dJoint = (LHDistanceJoint*)joint;
				b2DistanceJointDef jointDef;
				
				jointDef.Initialize(bodyA, 
									bodyB, 
									posA,
									posB);
				
				jointDef.collideConnected = collideConnected;
				
				jointDef.frequencyHz = [[joint objectForKey:@"Frequency"] floatValue];
				jointDef.dampingRatio = [[joint objectForKey:@"Damping"] floatValue];
				                
                LHJoint* jData = new LHJoint;
                jData->tag = tag;
                jointDef.userData = jData;
                
				if(0 != world)
				{
					return world->CreateJoint(&jointDef);
				}
			}	
				break;
				
			case LH_REVOLUTE_JOINT:
			{
				b2RevoluteJointDef jointDef;
				
				jointDef.Initialize(bodyA, bodyB, posA);
				
//				jointDef.referenceAngle = DEGREES_TO_RADIANS([[joint objectForKey:@"RefAngle"] floatValue]);
				jointDef.lowerAngle = DEGREES_TO_RADIANS([[joint objectForKey:@"LowerAngle"] floatValue]);
				jointDef.upperAngle = DEGREES_TO_RADIANS([[joint objectForKey:@"UpperAngle"] floatValue]);
				jointDef.motorSpeed = [[joint objectForKey:@"MotorSpeed"] floatValue]; //Usually in radians per second. ?????
				jointDef.maxMotorTorque = [[joint objectForKey:@"MaxTorque"] floatValue]; //Usually in N-m.  ?????
				jointDef.enableLimit = [[joint objectForKey:@"EnableLimit"] boolValue];
				jointDef.enableMotor = [[joint objectForKey:@"EnableMotor"] boolValue];
				
                LHJoint* jData = new LHJoint;
                jData->tag = tag;
                jointDef.userData = jData;
                
				if(0 != world)
				{
					return world->CreateJoint(&jointDef);
				}
			}
				break;
				
			case LH_PRISMATIC_JOINT:
				break;
				
			case LH_PULLEY_JOINT:
				break;
				
			case LH_GEAR_JOINT:
				break;
				
			case LH_LINE_JOINT:
				break;
				
			case LH_WELD_JOINT:
				break;
				
			default:
				NSLog(@"Unknown joint type in LevelHelper file.");
				break;
		}
	}
	
	return 0;
}
////////////////////////////////////////////////////////////////////////////////////
-(void)loadLevelHelperSceneFile:(NSString*)levelFile inDirectory:(NSString*)subfolder imgSubfolder:(NSString*)imgFolder
{
	NSString *path = [[NSBundle mainBundle] pathForResource:levelFile ofType:@"plhs" inDirectory:subfolder]; 
	
    NSString* str = [NSString stringWithFormat:@"Invalid level file \"%@\" Please add the LevelHelper scene file to Resource folder. Please do not add extension in the given string.", levelFile];
	NSAssert(nil!=path, str);
	
	NSDictionary *dictionary = [NSDictionary dictionaryWithContentsOfFile:path];
	
	[self processLevelFileFromDictionary:dictionary];
}

-(void)loadLevelHelperSceneFileFromWebAddress:(NSString*)webaddress
{	
	NSURL *url = [NSURL URLWithString:webaddress];
	
	NSDictionary *dictionary = [NSDictionary dictionaryWithContentsOfURL:url];
		
	if(dictionary == nil)
		NSLog(@"Provided web address is wrong or connection error.");
	
	[self processLevelFileFromDictionary:dictionary];
}

-(void)processLevelFileFromDictionary:(NSDictionary*)dictionary
{
	bool fileInCorrectFormat =	[[dictionary objectForKey:@"Author"] isEqualToString:@"Bogdan Vladu"] && 
	[[dictionary objectForKey:@"CreatedWith"] isEqualToString:@"LevelHelper"];
	
	if(fileInCorrectFormat == false)
		NSLog(@"This file was not created with LevelHelper or file is damaged.");
	
    if(convertLevel)
    {
        NSDictionary* scenePref = [dictionary objectForKey:@"ScenePreference"];
        CGPoint point = LHPointFromString([scenePref objectForKey:@"SafeFrame"]);
        
        CGSize winSize = [[CCDirector sharedDirector] winSize];
        
        convertRatio.x = winSize.width/point.x;
        convertRatio.y = winSize.height/point.y;
    }
    
	////////////////////////LOAD WORLD BOUNDARIES//////////////////////////////////////////////
	if(nil != [dictionary objectForKey:@"WBInfo"])
	{
		wb = [dictionary objectForKey:@"WBInfo"];
	}
	
	////////////////////////LOAD SPRITES////////////////////////////////////////////////////
    lhSprites = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"SPRITES_INFO"]];
	
	///////////////////////////LOAD BATCH IMAGES////////////////////////////////////////////
	NSArray* batchImages = [dictionary objectForKey:@"LoadedImages"];
	for(NSDictionary* imageInfo in batchImages)
	{
		NSMutableDictionary* batchInfo = [[NSMutableDictionary alloc] init];
		
        NSString* image = [imageInfo objectForKey:@"Image"];//[self imagePath:];        
		
		CCSpriteBatchNode *batch = [CCSpriteBatchNode batchNodeWithFile:[self imageFile:image]
															   capacity:BATCH_NODE_CAPACITY];	
		
		[batchInfo setObject:batch forKey:@"CCBatchNode"];
		[batchInfo setObject:[imageInfo objectForKey:@"OrderZ"] forKey:@"OrderZ"];
		
		
		[batchNodes setObject:batchInfo forKey:[imageInfo objectForKey:@"Image"]];
		[batchInfo release];
	}
	
	///////////////////////LOAD JOINTS//////////////////////////////////////////////////////////
	lhJoints = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"JOINTS_INFO"]];	

    //////////////////////LOAD PARALLAX/////////////////////////////////////////
    lhParallax = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"PARALLAX_INFO"]];
    
    ////////////////////LOAD BEZIER/////////////////////////////////////////////
    lhBeziers = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"BEZIER_INFO"]];
    
    ////////////////////LOAD ANIMS//////////////////////////////////////////////
    lhAnims = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"ANIMS_INFO"]];
    
    gravity = LHPointFromString([dictionary objectForKey:@"Gravity"]);
}
////////////////////////////////////////////////////////////////////////////////////
@end
